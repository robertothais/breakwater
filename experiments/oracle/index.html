<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>ASTX /get_pclog browser test (decode)</title>
    <script src="https://cdn.jsdelivr.net/npm/node-forge@1.3.1/dist/forge.min.js"></script>
    <style>
      body {
        font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
        padding: 16px;
      }
      pre {
        background: #111;
        color: #0f0;
        padding: 12px;
        border-radius: 8px;
        overflow: auto;
      }
      .dim {
        color: #888;
      }
    </style>
  </head>
  <body>
    <h1>ASTX /get_pclog test</h1>
    <p class="dim">Open DevTools console for detailed logs.</p>
    <div id="out"></div>

    <script>
      (async function () {
        // ---------------- DOM helpers ----------------
        const out = document.getElementById("out");
        const p = (html) => {
          const d = document.createElement("div");
          d.innerHTML = html;
          out.appendChild(d);
        };
        const pre = (label, text) => {
          const e = document.createElement("pre");
          e.textContent = text;
          out.appendChild(document.createTextNode(label));
          out.appendChild(e);
        };

        // ---------------- Utilities ----------------
        const hex = (u8) =>
          Array.from(u8, (b) => b.toString(16).padStart(2, "0")).join(" ");

        // Standard Base64 decoder (URL-safe tolerant) — for normal Base64 only
        function decodeStdBase64(str) {
          return Uint8Array.from(atob(str), (c) => c.charCodeAt(0));
        }

        // JSONP helper
        function jsonp(url) {
          return new Promise((resolve, reject) => {
            const cb = "cb" + Math.floor(Math.random() * 1e9);
            const s = document.createElement("script");
            window[cb] = (data) => {
              try {
                resolve(data);
              } finally {
                delete window[cb];
                s.remove();
              }
            };
            s.onerror = (e) => {
              delete window[cb];
              s.remove();
              reject(e);
            };
            s.src =
              url +
              (url.includes("?") ? "&" : "?") +
              "callback=" +
              cb +
              "&_=" +
              Date.now();
            document.body.appendChild(s);
          });
        }

        // ---------------- ASTX custom base64 ----------------
        function deriveAlphabet(salt) {
          const seed =
            "-f3_v8spVG29kzl5XuDNLci6rdoQy0ZFqmSACMgYbjRe7nPTOEKtawUhJ4HWIxB1";
          const step = salt < 1 ? 0x40 : (salt % 0x40) + 1; // observed: hello uses 8 -> step 9
          const out = [];
          let k = 0;
          while (out.length < 64) {
            for (let j = step - 1; j >= 0; j--) {
              const idx = j + step * k;
              if (idx < 64 && idx < seed.length) {
                out.push(seed[idx]);
                if (out.length >= 64) break;
              }
            }
            k++;
          }
          return out.join("");
        }

        function customB64DecodeToBytes(data, alphabet) {
          const map = new Map();
          for (let i = 0; i < alphabet.length; i++) map.set(alphabet[i], i);
          const out = [];
          let sextets = [];
          for (let ch of data) {
            if (ch === "*" || ch === "\0") break; // ASTX padding / terminator
            if (ch === " ") ch = "+"; // quirk seen in RE
            if (!map.has(ch)) continue;
            sextets.push(map.get(ch));
            if (sextets.length === 4) {
              const [a, b, c, d] = sextets;
              out.push((a << 2) | (b >> 4));
              out.push(((b & 0x0f) << 4) | (c >> 2));
              out.push(((c & 0x03) << 6) | d);
              sextets = [];
            }
          }
          if (sextets.length === 2) {
            const [a, b] = sextets;
            out.push((a << 2) | (b >> 4));
          } else if (sextets.length === 3) {
            const [a, b, c] = sextets;
            out.push((a << 2) | (b >> 4));
            out.push(((b & 0x0f) << 4) | (c >> 2));
          }
          return new Uint8Array(out);
        }

        function decodeHelloClientPublicKey(obf) {
          const alphabet = deriveAlphabet(8); // handleHello uses salt=8
          const buf = customB64DecodeToBytes(obf, alphabet);
          return new TextDecoder().decode(buf); // PEM
        }

        // ---------------- Heuristics for pclog_data ----------------
        function printableScore(u8) {
          let good = 0;
          for (let b of u8) {
            if (b === 0) return -1; // nulls usually mean wrong salt
            if (b === 9 || b === 10 || b === 13 || (b >= 32 && b <= 126))
              good++;
          }
          return u8.length ? good / u8.length : -1;
        }

        function tryDecodePclogAuto(obf) {
          const salts = [8];
          for (let s = 1; s <= 400; s++) if (s !== 8) salts.push(s);
          let best = { salt: null, score: -1, bytes: null };
          for (const s of salts) {
            try {
              const bytes = customB64DecodeToBytes(obf, deriveAlphabet(s));
              const sc = printableScore(bytes);
              if (sc > best.score) best = { salt: s, score: sc, bytes };
              if (sc >= 0.98) break; // good enough
            } catch {}
          }
          return best;
        }

        function parseLooseQuery(qs) {
          const params = {};
          for (const part of qs.split("&")) {
            const eqIndex = part.indexOf("=");
            if (eqIndex === -1) {
              params[part] = "";
            } else {
              const key = part.slice(0, eqIndex);
              const val = part.slice(eqIndex + 1);
              params[key] = val; // no decoding, raw string
            }
          }
          return params;
        }

        // ---------------- Flow ----------------
        console.log("[*] Fetching client_public_key via /hello …");
        const hello = await jsonp("http://localhost:8080/ASTX2/hello");
        console.log(hello);
        p("<b>/hello</b> result:");
        pre("", JSON.stringify(hello, null, 2));

        const pem = decodeHelloClientPublicKey(hello.client_public_key || "");
        console.log(pem || "(PEM decode failed)");
        p("<b>Decoded client_public_key (PEM)</b>:");
        pre("", pem || "(PEM decode failed)");

        console.log("[*] Calling /set_cert (step=1) …");
        const setCertUrl =
          "http://localhost:8080/ASTX2/set_cert" +
          "?v=3&step=1" +
          "&cert=s7nuorznq7z82i_z2PzG2T_3mR0TrPYcm7EH2rWsNBwED3wYGTexlvuprcz32rGp6rnoocm_26ev6e_GoPGpAv-X6d_oz_6wkcN7Gvexo30Qd7nric0zGvvKdrGQqvnrrdGcD3zkdiYNqvnv2cYzG3zId6GGz_mg2cuzr7nxG6_NGVYir6_5Gv_K2erErQG6leNWN3niqrnorcm_Nnev6e_GGvGpmfY0GBEnLrm3m6ewGj60q7z826zumPGGirY5AnYusR0BLPWprr6s2e_pG3mjG6ppGvz826_t2BmjGrupdfN8AveLL6zR2PEsid-PL70nre0pk8ek6vJPz3YcAfzOSPSXzv0ELRGO27_527GfScYp6ohCGep0d80ckrIPqRGpArhIoj_DzshKq7_YGQrIAjeylvEcDPPnq3YDS8uC5Peal2Y2D8NKoceOzvGI2R6Yod0MNvG_SeLPLrvIzPW9LiNWoivx5PeeSxztr7zLr7NdqiNHl3KO63hQN_N0o7CTGe-ts70MGrzlonzsmilTSdzw6QGi6vnjAyw_2imEd7WWdvzl63hHGczbzT0LSQ_RXP_OzPwidv03lswXiR6-AiY7r8lXq_YMrrufSjlPkc6TGr_ad768A3GNGsJK5nLI2eGlAj_kq80Xod0l267IA3zlNxNwAd_socpcoeuvlr_dAQ6NdVYC6TzzD_e62RNXmr0_Dx0Wm7hu2dms2j0_djpo2rbxoTm5kiu_r6exkd-WA6VMN6Yiq8082cm_2r_r2rWsNBwEsR0MDrSWmTps26_TG7_pdPzprr6pLxznm__WG7wNm769dcGj2Rw0A3m-2c7MS_pX6vZxDe_W2ibndiY0oRGwk_ZXN3YzzrG7SsCOLd0L2rrni7GTAQvB6PNvlinOr7vtq7NtNvNHSnzpm_NQN3wazRm3zf0pqjmsdBwX5B666BPTm2Y9iQG_znNN5xLtlj6lSB0GAfGdzohM5x6CrRG0oT6tz606LTNzAjuEljNeDBhODR-n2PNgAP0wlyw0ddpfmeNxsj06S8euleNao6_Qoj7I6PYXDrnDmrwBiivt66Y8lfmti7zvz_mYl3zzmvzfldmHDRwrGi65l_rM2RYs2TGu2R7XSrEnkiukod0NSdpWic0nA8mlDr6yzczIoRzoA3hHoRzIrnmRGjmXS_eCoRZMm7NHrRGL2BCMleGIl7eYL6NMzZYoqihGoBZnrQNtiiu2dx0sirWzGOwuk_pp2QlWqcunGcu9SPLxq8LMGvvh92b*" +
          "&pageid=" +
          Date.now().toString();

        const setCert = await jsonp(setCertUrl);
        console.log("[+] /set_cert reply:", setCert);
        p("<b>/set_cert</b> result:");
        pre("", JSON.stringify(setCert, null, 2));

        console.log("[*] Calling /get_pclog (minimal params, no key/data) …");
        const q =
          "http://localhost:8080/ASTX2/get_pclog" +
          "?v=3&ver=1&alg=1&svr=shinhanbank&norsa=0" +
          "&uniq=E89BFFA185B19806C3C608AED9D0329938F0344C998C6696D6020156DD0BB57D" +
          "&utime=" +
          Math.floor(Date.now() / 1000) +
          "&nlog=1&ipaddr=127.0.0.1" +
          "&pageid=" +
          Date.now().toString() +
          "&opt=";

        const pclog = await jsonp(q);
        console.log("[+] /get_pclog reply:", pclog);
        p("<b>/get_pclog</b> raw reply:");
        pre("", JSON.stringify(pclog, null, 2));

        const obf = (pclog && pclog.pclog_data) || "";
        if (!obf) {
          p("<b>pclog_data</b>: <span class='dim'>(missing)</span>");
          return;
        }

        console.log(
          "[*] Decoding pclog_data (auto-detect salt, try salt=8 first) …"
        );
        const best = tryDecodePclogAuto(obf);
        if (!best.bytes || best.score < 0) {
          p("<b>Decode failed</b>");
          return;
        }

        const decodedText = new TextDecoder().decode(best.bytes);
        console.log(
          `[+] Decoded (salt=${best.salt}, printable=${(
            best.score * 100
          ).toFixed(1)}%)`
        );
        console.log(decodedText);

        p(
          `<b>Decoded pclog_data</b> (salt=${best.salt}, printable ${(
            best.score * 100
          ).toFixed(1)}%):`
        );
        pre("", decodedText);

        // ---------------- Parse decoded pclog parameters ----------------
        console.log("[*] Parsing pclog parameters...");
        const params = parseLooseQuery(decodedText);
        const keyParam = params["key"];
        const dataParam = params["data"];
        const saltParam = params["salt"];

        p("<b>Extracted parameters</b>:");
        pre(
          "",
          `salt: ${saltParam}\nkey length: ${
            keyParam ? keyParam.length : "null"
          }\ndata length: ${dataParam ? dataParam.length : "null"}`
        );

        if (!keyParam || !dataParam) {
          p("<b>Missing key or data parameter</b>");
          return;
        }

        // ---------------- Decode key (standard base64) ----------------
        console.log("[*] Decoding key and data parameters...");
        const urlSalt = parseInt(params["salt"]);
        console.log(`[*] URL salt: ${urlSalt}`);

        console.log(`[*] Key parameter: ${keyParam.substring(0, 50)}...`);
        let keyDecoded = new Uint8Array(0);
        try {
          keyDecoded = decodeStdBase64(keyParam); // <— standard Base64 only
          console.log(`[+] Key decoded: ${keyDecoded.length} bytes`);
        } catch (e) {
          console.log(`[-] Key base64 decode failed: ${e.message}`);
        }

        // ---------------- Decode data (custom base64) ----------------
        console.log(
          `[*] Data parameter: ${dataParam.substring(0, 50)}... (ends with **)`
        );
        const dataBest = tryDecodePclogAuto(dataParam);
        console.log(
          `[+] Data decoded with salt=${dataBest.salt}: ${
            dataBest.bytes.length
          } bytes, score=${dataBest.score.toFixed(3)}`
        );
        const dataDecoded = dataBest.bytes;

        p(
          `<b>Key parameter (standard base64)</b> (${keyDecoded.length} bytes):`
        );
        pre("", keyParam);

        p(
          `<b>Data parameter (salt=${dataBest.salt})</b> (${dataDecoded.length} bytes):`
        );
        pre("", hex(dataDecoded));

        // Show data as string
        const dataAsString = new TextDecoder("utf-8").decode(dataDecoded);
        console.log(`[+] Data as string: ${dataAsString.substring(0, 100)}...`);
        p(`<b>Data parameter as string</b>:`);
        pre("", dataAsString);

        // ---------------- RSA decrypt the key ----------------
        console.log(
          `[*] Key appears to be RSA-encrypted data (${keyDecoded.length} bytes)`
        );

        if (keyDecoded.length > 0) {
          console.log("[*] Attempting RSA decryption of key...");
          try {
            const response = await fetch("http://localhost:8081/decrypt-rsa", {
              method: "POST",
              headers: {
                "Content-Type": "application/json",
              },
              body: JSON.stringify({
                encryptedData: btoa(String.fromCharCode(...keyDecoded)),
              }),
            });

            const result = await response.json();

            if (result.success) {
              console.log(
                `[+] RSA decryption successful: ${result.plaintextB64}`
              );
              p(`<b>RSA decrypted key</b> (${result.plaintextBytes} bytes):`);
              pre(
                "",
                hex(
                  Uint8Array.from(atob(result.plaintextB64), (c) =>
                    c.charCodeAt(0)
                  )
                )
              );
            } else {
              console.log(`[-] RSA decryption failed: ${result.error}`);
              p(`<b>RSA decryption failed</b>: ${result.error}`);
            }
          } catch (error) {
            console.log(`[-] RSA decryption request failed: ${error.message}`);
            p(`<b>RSA decryption request failed</b>: ${error.message}`);
          }
        }
      })();
    </script>
  </body>
</html>
