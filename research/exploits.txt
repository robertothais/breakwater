ASTx get_pclog Endpoint – Research Notes

Location: Exposed by ASTx localhost daemon.

Behavior: Returns “PC log” data — appears to include system/environment details used by ASTx for device fingerprinting and fraud detection.

Key Exchange Context ([SECTION_S2C_RSA_KEY])
Meaning: S2C = Server-to-Client RSA key.

What’s in config: The server’s RSA private + public key pair is shipped directly in the client’s encrypted config file.

Implication:

Normally, only the server holds the private key; client would store only the public key for verifying signatures or encrypting to server.

Here, the client has the private key too, which means it can generate signatures or decrypt S2C-encrypted data exactly like the real server.

In practice, the daemon will trust anything signed/encrypted with this key pair.

Possible uses in ASTx:

Decrypt: Server encrypts data (like session tokens) to client using server’s private key; client decrypts with same private key (this is already a cryptographic anti-pattern).

Sign: Server signs messages to prove authenticity; client verifies with public key — but shipping the private key defeats the purpose.

Mutual key exchange: Used as part of handshake to negotiate a symmetric session key for later traffic.

Attack angle: With the private key in hand, an attacker could impersonate the server locally:

Craft responses to the daemon that pass signature/handshake checks.

Potentially send any arbitrary key to the client in place of the real server’s.

Risk
No auth or origin check — any local process or website (via localhost request or DNS rebinding) can query get_pclog.

Data likely contains sensitive identifiers (HWID, OS version, installed modules, possibly active process list).

Private S2C key exposure means attacker can fake “server-authenticated” payloads to the daemon.

If you want, I can also add a diagram showing how this “private key on client” breaks the normal public-key model. That would make the danger of S2C impersonation instantly clear.


hort version: this is the HTTP handler behind the local “get PC log” endpoint. The banking site hits the daemon on localhost, this function parses the request, decrypts a server-provided bundle that tells it how to talk back, collects a bunch of local telemetry, encrypts that telemetry per the server’s instructions, and returns the encrypted blob to the browser as JSON so the page can forward it upstream.

What it does step-by-step (names in your dump):

Parse S2C parameters from the request

Reads three integers/strings from the HTTP body/params using those tiny helpers (FUN_080aff02, atoi, etc.).

local_7e8 = s2c_alg (algorithm selector)

local_7e4 = s2c_salt (custom base64 “salt/step”)

One more numeric flag local_7ec (norsa)

Also captures a couple of strings (server/endpoint, UA), stored later in local_6a8, local_6d8, local_708 (they’re logged as svr, ua, etc.).

Decrypt a server→client control blob (hybrid RSA→AES)

Gets the client’s RSA private key (getRSAPrivateKey() → local_7d4).

Calls getS2CDataVersion1(local_588, local_7e8, local_570, local_558) where:

local_7e8 = alg (1/2/3)

local_570 = data_encoded (custom-b64)

local_558 = aes_key_encoded (custom-b64, RSA-wrapped AES key)

That function (you decompiled earlier) does:

Custom-base64 decode (salted alphabet); if alg in {2,3} it RSA-decrypts the AES key with the private key, then AES-decrypts the data.

The plaintext result lands in local_588. They then log pubip [%s] and validate/normalize it (FUN_08111174), falling back to "unknown" if invalid.

Log context

Writes debug lines: s2c_alg, s2c_salt, s2c_key, then pubip, svr, norsa, ua.

Collect the “PC log” (the telemetry payload)

Starts a “run” (Run Start/Run End markers).

Builds an iterator (FUN_080b3c68, FUN_080b3c78) and loops with FUN_08089e26 / FUN_08089e6e / FUN_080b9f8e, appending each record to local_4f8.

The formatting shows separators inserted (&DAT_08423f07, &DAT_08423f09 → looks like “\t”, “\n” style separators).

Net effect: local_4f8 becomes a big text blob listing items (processes, modules, configs—whatever that iterator yields on this build).

Encrypt & package the telemetry for upload

Calls buildEncryptedTelemetryRequest(...) with:

the raw log blob (local_4f8),

the session/connection info (socket/FD local_804),

the flags (norsa/alg/ua), server strings, and the S2C-derived pieces,

it returns a string in local_4e0 — this is the encrypted (and usually base64’d) “PC log” package ready to send to the bank server.

Return JSON to the browser (local HTTP response)

If local_4e0 is non-empty:

local_800 = "{\"pclog_data\":" + local_4e0 + ", \"result\":\"ACK\"}"

Else it logs a failure string and still finishes.

Hygiene

Zeroes and clears sensitive buffers (the code has a ton of size=...; ptr = string.data(); memset(ptr, 0, size); clear()), frees RSA/AES buffers, etc.

Why this matters:

It confirms the flow you suspected: the browser page doesn't gather system data directly. It instructs the local daemon, which decrypts S2C instructions with a client-held private key, collects telemetry, encrypts it per server policy, and hands the encrypted blob back to the page as pclog_data for upload.

The presence of norsa and s2c_alg/salt lets the server choose between multiple cipher/packing variants.

The earlier RSA private key you recovered is functionally required for this path (alg 2/3) to work, because the daemon needs it to unwrap the AES session key that decrypts the S2C control data.

If you want to reproduce end-to-end outside the product:

Parse an on-wire request to this endpoint; extract s2c_alg, s2c_salt, data_encoded, aes_key_encoded, plus server strings.

Decrypt the S2C control with your recovered private key (exactly what your tool now does).

Generate a faux “PC log” blob and run it through the same buildEncryptedTelemetryRequest logic you reimplement (likely: serialize, maybe compress, then AES with server-specified key/IV/padding, maybe RSA/BASE64 wrap depending on norsa/alg).

Return {"pclog_data": <your blob>, "result":"ACK"} — the bank page should accept and forward it.

ASTx handleHello – what it does
High-level: builds a JSON reply for the browser → includes a status and an RSA-wrapped blob called client_public_key.

Step-by-step (from the decompile)
Prepare JSON container

Creates a small JSON object (via the ASTx JSON helpers).

Sets "result" to an OK/ACK string initially.

Gate/flag check

If a callback at param_3 exists and returns not 1, it flips "result" to a “not allowed / norsa” value and skips the crypto part.

Custom Base64 context

Calls initCustomBase64Context(ctx, 8) → this is the same custom alphabet path used elsewhere (salt/step = 8 for this flow).

Load S2C public key (from local config)

FUN_0806f970() returns the obfuscated S2C RSA public key string (the one we found under [SECTION_S2C_RSA_KEY]).

decodeObfuscatedRSAKey(buf, len) → produces the PEM public key.

Produce client_public_key field

FUN_080a9be2(outStr, ctx, pemS2CPub) → takes the decoded S2C public key and the base64 context and builds a string placed into the JSON as:

json
Copy
Edit
{"client_public_key": "<blob>"}
Based on call shape, this is the client’s public key (or a client handshake blob) encoded/encrypted using the S2C public key, then custom-base64’d for transport.

Rationale: they need the server to learn the client’s ephemeral public key (or session material) but only the real server should read it → encrypt to S2C public.

Immediately after, they zero and free intermediates (clears local_480 and local_4cc, wipes buffers), then resetCryptoContext().

Serialize & return

Serializes JSON to a string and returns it in the HTTP response body.

If the gate failed earlier, the JSON likely omits client_public_key and just returns the failure "result".

How this relates to S2C keys
S2C in this path uses only the S2C public key (from the config) to wrap the client’s material for the server.

Contrast with getS2CDataVersion1 (the telemetry path), which does use the S2C private key present in the client build (problematic) during its RSA step.

Net: handleHello looks like the initial handshake: client advertises something (likely its ephemeral public key) encrypted to S2C public, so only the real server can read it.

Security implications
Because this daemon listens on localhost without strong origin checks, any website (via DNS rebinding or permissive CORS) can hit /hello and harvest the JSON:

That JSON includes a server-readable blob (client_public_key). On its own it’s not plaintext, but it’s a live handshake artifact you probably don’t want exposed cross-origin.

The broader risk comes from other endpoints (e.g., get_pclog) and the fact the S2C private key is shipped (enabling server impersonation against the client in other flows).

Quick identifiers in code
Init custom B64: initCustomBase64Context(local_468, 8)

Load obfuscated S2C public: FUN_0806f970()

De-obfuscate S2C public: decodeObfuscatedRSAKey(ptr, len)

Build client_public_key: FUN_080a9be2(local_480, local_468, local_4cc)

JSON field set: key "client_public_key"
