
â¸»

ğŸ›  Detection & Bypass Strategies for Linux Security Apps

1. Filesystem & /proc Checks

What they check:
	â€¢	/proc/cpuinfo â†’ CPU vendor/model (detects â€œQEMUâ€, â€œVMwareâ€, â€œVirtual CPUâ€)
	â€¢	/proc/meminfo â†’ available RAM
	â€¢	/proc/modules or /sys/module/â€¦ â†’ kernel modules loaded (security driver)
	â€¢	/proc/version â†’ kernel version string
	â€¢	/sys/class/net/*/address â†’ MAC address vendor (VMware, VirtualBox OUIs)
	â€¢	/sys/block/* â†’ disk model (detects â€œVBOXâ€, â€œQEMU HARDDISKâ€)

How to fake:
	â€¢	Precreate static files in rootfs with plausible host-like content.
	â€¢	Bind-mount real host /proc files (in real Linux VM) or use static text in CheerpX rootfs.
	â€¢	Change MAC addresses in static files to real vendor OUIs (Intel, Realtek).
	â€¢	Remove obvious â€œQEMUâ€, â€œVBOXâ€ identifiers.

â¸»

2. Kernel Module Presence

What they check:
	â€¢	stat("/sys/module/astx") or init_module() success.
	â€¢	ioctl() to /dev/astx* device.

How to fake:
	â€¢	Create fake /sys/module/astx directory + placeholder files.
	â€¢	Intercept open("/dev/astxâ€¦") in LD_PRELOAD â†’ return /dev/null fd.
	â€¢	Hook ioctl in shim to return success and dummy structs.

â¸»

3. Hardware Device Queries

What they check:
	â€¢	ethtool â†’ network link state
	â€¢	hdparm â†’ HDD model/serial
	â€¢	cpuid â†’ CPU feature bits

How to fake:
	â€¢	Replace ethtool, hdparm, cpuid with tiny stand-in binaries that echo plausible values and exit 0.
	â€¢	Or intercept in LD_PRELOAD â†’ detect via argv and spoof stdout.

â¸»

4. Networking & Netfilter

What they check:
	â€¢	libnetfilter-conntrack / libnfnetlink â†’ open netlink socket, query conntrack table.
	â€¢	iptables -L output.
	â€¢	Ability to bind to low-number ports.

How to fake:
	â€¢	Stub out netlink calls in shim to return empty-but-valid results.
	â€¢	Provide dummy /sbin/iptables that outputs a standard ruleset.
	â€¢	Always return EPERM for privileged binds, unless app treats as failure (then patch to skip).

â¸»

5. Environment & D-Bus

What they check:
	â€¢	dconf-cli / dconf-tools â†’ GNOME/desktop settings.
	â€¢	D-Bus service presence.

How to fake:
	â€¢	Install minimal dconf binary (no-op) in rootfs.
	â€¢	Provide /usr/bin/dbus-send wrapper that fakes expected responses.

â¸»

6. System Calls & Privileges

What they check:
	â€¢	uname() â†’ kernel release string
	â€¢	prctl(PR_CAPBSET_READ, CAP_SYS_ADMIN) â†’ check capabilities
	â€¢	geteuid() vs getuid() for root detection
	â€¢	seccomp or ptrace anti-debug

How to fake:
	â€¢	LD_PRELOAD hook for uname â†’ return plausible release string.
	â€¢	Intercept prctl to return â€œcap presentâ€ when needed.
	â€¢	Patch binary to skip seccomp/ptrace exit paths.

â¸»

7. File Hash / Binary Integrity

What they check:
	â€¢	SHA1/MD5 of installed helper binaries.
	â€¢	Presence of specific files in install dirs.

How to fake:
	â€¢	Keep exact filenames + dummy content with matching size/timestamps.
	â€¢	If hashes are checked, copy from real install.

â¸»

8. VM Detection

Common signals:
	â€¢	Strings in /proc/cpuinfo (vendor_id, model name)
	â€¢	PCI vendor IDs in /sys/bus/pci/devices/*/vendor (e.g., 0x80ee VirtualBox)
	â€¢	DMI data in /sys/class/dmi/id/* (manufacturer, product name)

How to fake:
	â€¢	Replace text files in /sys/class/dmi/id/ with realistic values (Lenovo, Dell, etc.).
	â€¢	Edit /proc/cpuinfo vendor_id and model name in rootfs copy.
	â€¢	Patch binary if it does string compares internally.

â¸»

ğŸ“¦ Implementation Layers
	1.	Rootfs Editing
	â€¢	Static text replacements for /proc, /sys, /dev paths inside emulatorâ€™s root filesystem.
	2.	Binary Shims
	â€¢	Drop-in replacements for called tools (ethtool, hdparm, cpuid, iptables) that just print expected output.
	3.	LD_PRELOAD Interception
	â€¢	Hook libc functions: open, ioctl, uname, socket, prctl, read (for /proc/*) to return faked values.
	4.	Binary Patching
	â€¢	Remove or invert return-value checks for VM/kernel detection logic.
	5.	Dynamic Response Shaping
	â€¢	If app parses JSON/XML/Netlink, intercept and feed benign but valid structures.

â¸»

ğŸ”‘ Key Principle

For browser/emulator contexts (CheerpX):

Make every expected dependency appear to succeed â€” whether itâ€™s a file, a device, a command, or a syscall â€” and return â€œhealthyâ€ values that match a plausible physical Linux machine.

â¸»

If you want, I can now map this cheat sheet directly to ASTxâ€™s .deb contents so youâ€™ll have a per-binary fake plan. That would give you a blueprint from unpack â†’ rootfs prep â†’ CheerpX launch.
